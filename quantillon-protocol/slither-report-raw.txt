'forge clean' running (wd: /home/uld/GitHub/smart-contracts/quantillon-protocol)
'forge config --json' running
'forge build --build-info --skip */test/** */script/** --force' running (wd: /home/uld/GitHub/smart-contracts/quantillon-protocol)

YieldShift.harvestAndDistributeAaveYield() (src/core/yieldmanagement/YieldShift.sol#715-724) uses arbitrary from in transferFrom: usdc.safeTransferFrom(address(aaveVault),address(this),yieldHarvested) (src/core/yieldmanagement/YieldShift.sol#719)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#arbitrary-from-in-transferfrom

HedgerPool.recoverETH(address) (src/core/HedgerPool.sol#914-923) sends eth to arbitrary user
	Dangerous calls:
	- (success,None) = to.call{value: balance}() (src/core/HedgerPool.sol#921)
QEUROToken.recoverETH(address) (src/core/QEUROToken.sol#1161-1170) sends eth to arbitrary user
	Dangerous calls:
	- (success,None) = to.call{value: balance}() (src/core/QEUROToken.sol#1168)
QTIToken.recoverETH(address) (src/core/QTIToken.sol#1054-1062) sends eth to arbitrary user
	Dangerous calls:
	- (success,None) = to.call{value: balance}() (src/core/QTIToken.sol#1060)
QuantillonVault.recoverETH(address) (src/core/QuantillonVault.sol#582-591) sends eth to arbitrary user
	Dangerous calls:
	- (success,None) = to.call{value: balance}() (src/core/QuantillonVault.sol#589)
UserPool.recoverETH(address) (src/core/UserPool.sol#1134-1142) sends eth to arbitrary user
	Dangerous calls:
	- (success,None) = to.call{value: balance}() (src/core/UserPool.sol#1140)
stQEUROToken.recoverETH(address) (src/core/stQEUROToken.sol#744-753) sends eth to arbitrary user
	Dangerous calls:
	- (success,None) = to.call{value: balance}() (src/core/stQEUROToken.sol#751)
AaveVault.recoverETH(address) (src/core/vaults/AaveVault.sol#612-620) sends eth to arbitrary user
	Dangerous calls:
	- (success,None) = to.call{value: balance}() (src/core/vaults/AaveVault.sol#618)
YieldShift.recoverETH(address) (src/core/yieldmanagement/YieldShift.sol#835-843) sends eth to arbitrary user
	Dangerous calls:
	- (success,None) = to.call{value: balance}() (src/core/yieldmanagement/YieldShift.sol#841)
ChainlinkOracle.recoverETH(address) (src/oracle/ChainlinkOracle.sol#638-647) sends eth to arbitrary user
	Dangerous calls:
	- (success,None) = to.call{value: balance}() (src/oracle/ChainlinkOracle.sol#645)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#functions-that-send-ether-to-arbitrary-destinations

QTIToken.proposalExecutionTime (src/core/QTIToken.sol#227) is never initialized. It is used in:
	- QTIToken.getProposalExecutionInfo(uint256) (src/core/QTIToken.sol#811-819)
QTIToken.proposalExecutionHash (src/core/QTIToken.sol#229) is never initialized. It is used in:
	- QTIToken.getProposalExecutionHash(uint256) (src/core/QTIToken.sol#826-828)
QTIToken.proposalScheduled (src/core/QTIToken.sol#231) is never initialized. It is used in:
	- QTIToken.getProposalExecutionInfo(uint256) (src/core/QTIToken.sol#811-819)
UserPool.accumulatedYieldPerShare (src/core/UserPool.sol#219) is never initialized. It is used in:
	- UserPool._updatePendingRewards(address) (src/core/UserPool.sol#804-843)
	- UserPool.getUserPendingRewards(address) (src/core/UserPool.sol#872-901)
YieldShift.yieldShiftHistory (src/core/yieldmanagement/YieldShift.sol#158) is never initialized. It is used in:
	- YieldShift.getHistoricalYieldShift(uint256) (src/core/yieldmanagement/YieldShift.sol#512-568)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-state-variables

HedgerPool._updateHedgerRewards(address) (src/core/HedgerPool.sol#660-692) uses a dangerous strict equality:
	- lastRewardBlock == 0 (src/core/HedgerPool.sol#667)
HedgerPool.recoverETH(address) (src/core/HedgerPool.sol#914-923) uses a dangerous strict equality:
	- balance == 0 (src/core/HedgerPool.sol#919)
QEUROToken.recoverETH(address) (src/core/QEUROToken.sol#1161-1170) uses a dangerous strict equality:
	- balance == 0 (src/core/QEUROToken.sol#1164)
QTIToken.recoverETH(address) (src/core/QTIToken.sol#1054-1062) uses a dangerous strict equality:
	- balance == 0 (src/core/QTIToken.sol#1057)
UserPool._updatePendingRewards(address) (src/core/UserPool.sol#804-843) uses a dangerous strict equality:
	- lastRewardBlock == 0 (src/core/UserPool.sol#812)
UserPool.getUserPendingRewards(address) (src/core/UserPool.sol#872-901) uses a dangerous strict equality:
	- lastRewardBlock == 0 (src/core/UserPool.sol#881)
AaveVault.autoRebalance() (src/core/vaults/AaveVault.sol#452-475) uses a dangerous strict equality:
	- totalAssets == 0 (src/core/vaults/AaveVault.sol#462)
AaveVault.recoverETH(address) (src/core/vaults/AaveVault.sol#612-620) uses a dangerous strict equality:
	- balance == 0 (src/core/vaults/AaveVault.sol#616)
AaveVault.withdrawFromAave(uint256) (src/core/vaults/AaveVault.sol#241-300) uses a dangerous strict equality:
	- aaveBalance == 0 (src/core/vaults/AaveVault.sol#250)
YieldShift.addYield(uint256,bytes32) (src/core/yieldmanagement/YieldShift.sol#261-298) uses a dangerous strict equality:
	- require(bool,string)(balanceAfter - balanceBefore == yieldAmount,Yield amount mismatch) (src/core/yieldmanagement/YieldShift.sol#278-281)
YieldShift.recoverETH(address) (src/core/yieldmanagement/YieldShift.sol#835-843) uses a dangerous strict equality:
	- balance == 0 (src/core/yieldmanagement/YieldShift.sol#839)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities

Reentrancy in UserPool.batchDeposit(uint256[],uint256[]) (src/core/UserPool.sol#420-485):
	External calls:
	- vault.mintQEURO(netAmount,minQeuroOut) (src/core/UserPool.sol#468)
	State variables written after the call(s):
	- totalDeposits += netAmount (src/core/UserPool.sol#478)
	UserPool.totalDeposits (src/core/UserPool.sol#173) can be used in cross function reentrancies:
	- UserPool.getPoolMetrics() (src/core/UserPool.sol#952-962)
	- UserPool.getTotalDeposits() (src/core/UserPool.sol#933-935)
	- UserPool.totalDeposits (src/core/UserPool.sol#173)
	- user.qeuroBalance += uint128(qeuroMinted) (src/core/UserPool.sol#476)
	UserPool.userInfo (src/core/UserPool.sol#208) can be used in cross function reentrancies:
	- UserPool.emergencyUnstake(address) (src/core/UserPool.sol#1054-1064)
	- UserPool.getUserDeposits(address) (src/core/UserPool.sol#854-856)
	- UserPool.getUserInfo(address) (src/core/UserPool.sol#912-927)
	- UserPool.getUserPendingRewards(address) (src/core/UserPool.sol#872-901)
	- UserPool.getUserStakes(address) (src/core/UserPool.sol#863-865)
	- UserPool.userInfo (src/core/UserPool.sol#208)
	- user.depositHistory += uint96(usdcAmount) (src/core/UserPool.sol#477)
	UserPool.userInfo (src/core/UserPool.sol#208) can be used in cross function reentrancies:
	- UserPool.emergencyUnstake(address) (src/core/UserPool.sol#1054-1064)
	- UserPool.getUserDeposits(address) (src/core/UserPool.sol#854-856)
	- UserPool.getUserInfo(address) (src/core/UserPool.sol#912-927)
	- UserPool.getUserPendingRewards(address) (src/core/UserPool.sol#872-901)
	- UserPool.getUserStakes(address) (src/core/UserPool.sol#863-865)
	- UserPool.userInfo (src/core/UserPool.sol#208)
Reentrancy in UserPool.batchRewardClaim(address[]) (src/core/UserPool.sol#748-776):
	External calls:
	- qeuro.mint(user,rewardAmount) (src/core/UserPool.sol#771)
	State variables written after the call(s):
	- _updatePendingRewards(user) (src/core/UserPool.sol#761)
		- userdata.pendingRewards += uint128(stakingReward + yieldReward) (src/core/UserPool.sol#837)
		- userdata.lastStakeTime = uint64(block.timestamp) (src/core/UserPool.sol#838)
	UserPool.userInfo (src/core/UserPool.sol#208) can be used in cross function reentrancies:
	- UserPool.emergencyUnstake(address) (src/core/UserPool.sol#1054-1064)
	- UserPool.getUserDeposits(address) (src/core/UserPool.sol#854-856)
	- UserPool.getUserInfo(address) (src/core/UserPool.sol#912-927)
	- UserPool.getUserPendingRewards(address) (src/core/UserPool.sol#872-901)
	- UserPool.getUserStakes(address) (src/core/UserPool.sol#863-865)
	- UserPool.userInfo (src/core/UserPool.sol#208)
	- userInfo_.pendingRewards = 0 (src/core/UserPool.sol#768)
	UserPool.userInfo (src/core/UserPool.sol#208) can be used in cross function reentrancies:
	- UserPool.emergencyUnstake(address) (src/core/UserPool.sol#1054-1064)
	- UserPool.getUserDeposits(address) (src/core/UserPool.sol#854-856)
	- UserPool.getUserInfo(address) (src/core/UserPool.sol#912-927)
	- UserPool.getUserPendingRewards(address) (src/core/UserPool.sol#872-901)
	- UserPool.getUserStakes(address) (src/core/UserPool.sol#863-865)
	- UserPool.userInfo (src/core/UserPool.sol#208)
	- _updatePendingRewards(user) (src/core/UserPool.sol#761)
		- userLastRewardBlock[user] = currentBlock (src/core/UserPool.sol#814)
		- userLastRewardBlock[user] = currentBlock (src/core/UserPool.sol#841)
	UserPool.userLastRewardBlock (src/core/UserPool.sol#232) can be used in cross function reentrancies:
	- UserPool.getUserPendingRewards(address) (src/core/UserPool.sol#872-901)
	- UserPool.userLastRewardBlock (src/core/UserPool.sol#232)
Reentrancy in UserPool.batchWithdraw(uint256[],uint256[]) (src/core/UserPool.sol#538-596):
	External calls:
	- vault.redeemQEURO(qeuroAmount,minUsdcOut) (src/core/UserPool.sol#574)
	State variables written after the call(s):
	- totalDeposits -= netAmount (src/core/UserPool.sol#589)
	UserPool.totalDeposits (src/core/UserPool.sol#173) can be used in cross function reentrancies:
	- UserPool.getPoolMetrics() (src/core/UserPool.sol#952-962)
	- UserPool.getTotalDeposits() (src/core/UserPool.sol#933-935)
	- UserPool.totalDeposits (src/core/UserPool.sol#173)
	- user.qeuroBalance -= uint128(qeuroAmount) (src/core/UserPool.sol#586)
	UserPool.userInfo (src/core/UserPool.sol#208) can be used in cross function reentrancies:
	- UserPool.emergencyUnstake(address) (src/core/UserPool.sol#1054-1064)
	- UserPool.getUserDeposits(address) (src/core/UserPool.sol#854-856)
	- UserPool.getUserInfo(address) (src/core/UserPool.sol#912-927)
	- UserPool.getUserPendingRewards(address) (src/core/UserPool.sol#872-901)
	- UserPool.getUserStakes(address) (src/core/UserPool.sol#863-865)
	- UserPool.userInfo (src/core/UserPool.sol#208)
Reentrancy in AaveVault.deployToAave(uint256) (src/core/vaults/AaveVault.sol#212-239):
	External calls:
	- aavePool.supply(address(usdc),amount,address(this),0) (src/core/vaults/AaveVault.sol#231)
	State variables written after the call(s):
	- principalDeposited += amount (src/core/vaults/AaveVault.sol#236)
	AaveVault.principalDeposited (src/core/vaults/AaveVault.sol#147) can be used in cross function reentrancies:
	- AaveVault.emergencyWithdrawFromAave() (src/core/vaults/AaveVault.sol#503-542)
	- AaveVault.getAavePositionDetails() (src/core/vaults/AaveVault.sol#406-416)
	- AaveVault.getAvailableYield() (src/core/vaults/AaveVault.sol#369-377)
	- AaveVault.principalDeposited (src/core/vaults/AaveVault.sol#147)
Reentrancy in UserPool.deposit(uint256,uint256) (src/core/UserPool.sol#366-410):
	External calls:
	- vault.mintQEURO(netAmount,minQeuroOut) (src/core/UserPool.sol#395)
	State variables written after the call(s):
	- user.qeuroBalance += uint128(qeuroMinted) (src/core/UserPool.sol#402)
	UserPool.userInfo (src/core/UserPool.sol#208) can be used in cross function reentrancies:
	- UserPool.emergencyUnstake(address) (src/core/UserPool.sol#1054-1064)
	- UserPool.getUserDeposits(address) (src/core/UserPool.sol#854-856)
	- UserPool.getUserInfo(address) (src/core/UserPool.sol#912-927)
	- UserPool.getUserPendingRewards(address) (src/core/UserPool.sol#872-901)
	- UserPool.getUserStakes(address) (src/core/UserPool.sol#863-865)
	- UserPool.userInfo (src/core/UserPool.sol#208)
	- user.depositHistory += uint96(usdcAmount) (src/core/UserPool.sol#403)
	UserPool.userInfo (src/core/UserPool.sol#208) can be used in cross function reentrancies:
	- UserPool.emergencyUnstake(address) (src/core/UserPool.sol#1054-1064)
	- UserPool.getUserDeposits(address) (src/core/UserPool.sol#854-856)
	- UserPool.getUserInfo(address) (src/core/UserPool.sol#912-927)
	- UserPool.getUserPendingRewards(address) (src/core/UserPool.sol#872-901)
	- UserPool.getUserStakes(address) (src/core/UserPool.sol#863-865)
	- UserPool.userInfo (src/core/UserPool.sol#208)
Reentrancy in QuantillonVault.redeemQEURO(uint256,uint256) (src/core/QuantillonVault.sol#319-362):
	External calls:
	- qeuro.burn(msg.sender,qeuroAmount) (src/core/QuantillonVault.sol#350)
	State variables written after the call(s):
	- totalUsdcHeld -= usdcToReturn (src/core/QuantillonVault.sol#354)
	QuantillonVault.totalUsdcHeld (src/core/QuantillonVault.sol#141) can be used in cross function reentrancies:
	- QuantillonVault.getVaultMetrics() (src/core/QuantillonVault.sol#379-398)
	- QuantillonVault.totalUsdcHeld (src/core/QuantillonVault.sol#141)
	- QuantillonVault.withdrawProtocolFees(address) (src/core/QuantillonVault.sol#487-496)
Reentrancy in UserPool.withdraw(uint256,uint256) (src/core/UserPool.sol#495-528):
	External calls:
	- vault.redeemQEURO(qeuroAmount,minUsdcOut) (src/core/UserPool.sol#511)
	State variables written after the call(s):
	- user.qeuroBalance -= uint128(qeuroAmount) (src/core/UserPool.sol#519)
	UserPool.userInfo (src/core/UserPool.sol#208) can be used in cross function reentrancies:
	- UserPool.emergencyUnstake(address) (src/core/UserPool.sol#1054-1064)
	- UserPool.getUserDeposits(address) (src/core/UserPool.sol#854-856)
	- UserPool.getUserInfo(address) (src/core/UserPool.sol#912-927)
	- UserPool.getUserPendingRewards(address) (src/core/UserPool.sol#872-901)
	- UserPool.getUserStakes(address) (src/core/UserPool.sol#863-865)
	- UserPool.userInfo (src/core/UserPool.sol#208)
Reentrancy in AaveVault.withdrawFromAave(uint256) (src/core/vaults/AaveVault.sol#241-300):
	External calls:
	- withdrawn = aavePool.withdraw(address(usdc),withdrawAmount,address(this)) (src/core/vaults/AaveVault.sol#268-299)
	State variables written after the call(s):
	- principalDeposited -= principalWithdrawn (src/core/vaults/AaveVault.sol#291)
	AaveVault.principalDeposited (src/core/vaults/AaveVault.sol#147) can be used in cross function reentrancies:
	- AaveVault.emergencyWithdrawFromAave() (src/core/vaults/AaveVault.sol#503-542)
	- AaveVault.getAavePositionDetails() (src/core/vaults/AaveVault.sol#406-416)
	- AaveVault.getAvailableYield() (src/core/vaults/AaveVault.sol#369-377)
	- AaveVault.principalDeposited (src/core/vaults/AaveVault.sol#147)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-1

HedgerPool.liquidateHedger(address,uint256,bytes32) (src/core/HedgerPool.sol#579-624) ignores return value by (None,isValid) = oracle.getEurUsdPrice() (src/core/HedgerPool.sol#599)
HedgerPool.claimHedgingRewards() (src/core/HedgerPool.sol#626-658) ignores return value by yieldShift.claimHedgerYield(hedger) (src/core/HedgerPool.sol#651)
HedgerPool.getHedgerPosition(address,uint256) (src/core/HedgerPool.sol#694-719) ignores return value by (currentPrice,None) = oracle.getEurUsdPrice() (src/core/HedgerPool.sol#709)
AaveVault.autoRebalance() (src/core/vaults/AaveVault.sol#452-475) ignores return value by (optimalAllocation,None) = this.calculateOptimalAllocation() (src/core/vaults/AaveVault.sol#458)
AaveVault.getRiskMetrics() (src/core/vaults/AaveVault.sol#544-555) ignores return value by (None,utilizationRate,None,None) = this.getAaveMarketData() (src/core/vaults/AaveVault.sol#553)
YieldShift.getYieldPerformanceMetrics() (src/core/yieldmanagement/YieldShift.sol#570-588) ignores return value by (totalUsers,None,None,None) = userPool.getPoolMetrics() (src/core/yieldmanagement/YieldShift.sol#578)
ChainlinkOracle._updatePrices() (src/oracle/ChainlinkOracle.sol#253-320) ignores return value by (None,eurUsdRawPrice,None,eurUsdUpdatedAt,None) = eurUsdPriceFeed.latestRoundData() (src/oracle/ChainlinkOracle.sol#255)
ChainlinkOracle._updatePrices() (src/oracle/ChainlinkOracle.sol#253-320) ignores return value by (None,usdcUsdRawPrice,None,usdcUsdUpdatedAt,None) = usdcUsdPriceFeed.latestRoundData() (src/oracle/ChainlinkOracle.sol#258)
ChainlinkOracle.getOracleHealth() (src/oracle/ChainlinkOracle.sol#363-406) ignores return value by (updatedAt) = eurUsdPriceFeed.latestRoundData() (src/oracle/ChainlinkOracle.sol#373-383)
ChainlinkOracle.getOracleHealth() (src/oracle/ChainlinkOracle.sol#363-406) ignores return value by (updatedAt_scope_0) = usdcUsdPriceFeed.latestRoundData() (src/oracle/ChainlinkOracle.sol#386-396)
ChainlinkOracle.getEurUsdDetails() (src/oracle/ChainlinkOracle.sol#417-484) ignores return value by (rawPrice,updatedAt) = eurUsdPriceFeed.latestRoundData() (src/oracle/ChainlinkOracle.sol#432-463)
ChainlinkOracle.getEurUsdDetails() (src/oracle/ChainlinkOracle.sol#417-484) ignores return value by (updatedAt_scope_0) = eurUsdPriceFeed.latestRoundData() (src/oracle/ChainlinkOracle.sol#470-480)
ChainlinkOracle.checkPriceFeedConnectivity() (src/oracle/ChainlinkOracle.sol#549-588) ignores return value by (roundId) = eurUsdPriceFeed.latestRoundData() (src/oracle/ChainlinkOracle.sol#560-572)
ChainlinkOracle.checkPriceFeedConnectivity() (src/oracle/ChainlinkOracle.sol#549-588) ignores return value by (roundId_scope_0) = usdcUsdPriceFeed.latestRoundData() (src/oracle/ChainlinkOracle.sol#575-587)
ChainlinkOracle.getEurUsdPrice() (src/oracle/ChainlinkOracle.sol#696-737) ignores return value by (None,rawPrice,None,updatedAt,None) = eurUsdPriceFeed.latestRoundData() (src/oracle/ChainlinkOracle.sol#703)
ChainlinkOracle.getUsdcUsdPrice() (src/oracle/ChainlinkOracle.sol#748-773) ignores return value by (None,rawPrice,None,updatedAt,None) = usdcUsdPriceFeed.latestRoundData() (src/oracle/ChainlinkOracle.sol#750)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return

HedgerPool.initialize(address,address,address,address,address).timelock (src/core/HedgerPool.sol#254) shadows:
	- SecureUpgradeable.timelock (src/core/SecureUpgradeable.sol#25) (state variable)
QEUROToken.initialize(address,address,address).timelock (src/core/QEUROToken.sol#276) shadows:
	- SecureUpgradeable.timelock (src/core/SecureUpgradeable.sol#25) (state variable)
QTIToken.initialize(address,address,address).timelock (src/core/QTIToken.sol#319) shadows:
	- SecureUpgradeable.timelock (src/core/SecureUpgradeable.sol#25) (state variable)
QuantillonVault.initialize(address,address,address,address,address).timelock (src/core/QuantillonVault.sol#216) shadows:
	- SecureUpgradeable.timelock (src/core/SecureUpgradeable.sol#25) (state variable)
UserPool.initialize(address,address,address,address,address,address).timelock (src/core/UserPool.sol#321) shadows:
	- SecureUpgradeable.timelock (src/core/SecureUpgradeable.sol#25) (state variable)
stQEUROToken.initialize(address,address,address,address,address,address).timelock (src/core/stQEUROToken.sol#252) shadows:
	- SecureUpgradeable.timelock (src/core/SecureUpgradeable.sol#25) (state variable)
AaveVault.initialize(address,address,address,address,address,address).timelock (src/core/vaults/AaveVault.sol#176) shadows:
	- SecureUpgradeable.timelock (src/core/SecureUpgradeable.sol#25) (state variable)
YieldShift.initialize(address,address,address,address,address,address,address).timelock (src/core/yieldmanagement/YieldShift.sol#195) shadows:
	- SecureUpgradeable.timelock (src/core/SecureUpgradeable.sol#25) (state variable)
IHedgerPool.getHedgingConfig().minMarginRatio (src/interfaces/IHedgerPool.sol#54) shadows:
	- IHedgerPool.minMarginRatio() (src/interfaces/IHedgerPool.sol#76) (function)
IHedgerPool.getHedgingConfig().liquidationThreshold (src/interfaces/IHedgerPool.sol#55) shadows:
	- IHedgerPool.liquidationThreshold() (src/interfaces/IHedgerPool.sol#77) (function)
IHedgerPool.getHedgingConfig().maxLeverage (src/interfaces/IHedgerPool.sol#56) shadows:
	- IHedgerPool.maxLeverage() (src/interfaces/IHedgerPool.sol#78) (function)
IHedgerPool.getHedgingConfig().liquidationPenalty (src/interfaces/IHedgerPool.sol#57) shadows:
	- IHedgerPool.liquidationPenalty() (src/interfaces/IHedgerPool.sol#79) (function)
IHedgerPool.getHedgingConfig().entryFee (src/interfaces/IHedgerPool.sol#58) shadows:
	- IHedgerPool.entryFee() (src/interfaces/IHedgerPool.sol#80) (function)
IHedgerPool.getHedgingConfig().exitFee (src/interfaces/IHedgerPool.sol#59) shadows:
	- IHedgerPool.exitFee() (src/interfaces/IHedgerPool.sol#81) (function)
IHedgerPool.hedgers(address).totalMargin (src/interfaces/IHedgerPool.sol#105) shadows:
	- IHedgerPool.totalMargin() (src/interfaces/IHedgerPool.sol#83) (function)
IHedgerPool.hedgers(address).totalExposure (src/interfaces/IHedgerPool.sol#106) shadows:
	- IHedgerPool.totalExposure() (src/interfaces/IHedgerPool.sol#84) (function)
IQTIToken.getGovernanceInfo().totalLocked (src/interfaces/IQTIToken.sol#198) shadows:
	- IQTIToken.totalLocked() (src/interfaces/IQTIToken.sol#252) (function)
IQTIToken.getGovernanceInfo().totalVotingPower (src/interfaces/IQTIToken.sol#199) shadows:
	- IQTIToken.totalVotingPower() (src/interfaces/IQTIToken.sol#253) (function)
IQTIToken.getGovernanceInfo().proposalThreshold (src/interfaces/IQTIToken.sol#200) shadows:
	- IQTIToken.proposalThreshold() (src/interfaces/IQTIToken.sol#265) (function)
IQTIToken.getGovernanceInfo().quorumVotes (src/interfaces/IQTIToken.sol#201) shadows:
	- IQTIToken.quorumVotes() (src/interfaces/IQTIToken.sol#268) (function)
IQTIToken.getGovernanceInfo().currentDecentralizationLevel (src/interfaces/IQTIToken.sol#202) shadows:
	- IQTIToken.currentDecentralizationLevel() (src/interfaces/IQTIToken.sol#272) (function)
IUserPool.getPoolConfig().stakingAPY (src/interfaces/IUserPool.sol#196) shadows:
	- IUserPool.stakingAPY() (src/interfaces/IUserPool.sol#236) (function)
IUserPool.getPoolConfig().depositAPY (src/interfaces/IUserPool.sol#197) shadows:
	- IUserPool.depositAPY() (src/interfaces/IUserPool.sol#237) (function)
IUserPool.getPoolConfig().minStakeAmount (src/interfaces/IUserPool.sol#198) shadows:
	- IUserPool.minStakeAmount() (src/interfaces/IUserPool.sol#238) (function)
IUserPool.getPoolConfig().unstakingCooldown (src/interfaces/IUserPool.sol#199) shadows:
	- IUserPool.unstakingCooldown() (src/interfaces/IUserPool.sol#239) (function)
IUserPool.getPoolConfig().depositFee (src/interfaces/IUserPool.sol#200) shadows:
	- IUserPool.depositFee() (src/interfaces/IUserPool.sol#240) (function)
IUserPool.getPoolConfig().withdrawalFee (src/interfaces/IUserPool.sol#201) shadows:
	- IUserPool.withdrawalFee() (src/interfaces/IUserPool.sol#241) (function)
IUserPool.getPoolConfig().performanceFee (src/interfaces/IUserPool.sol#202) shadows:
	- IUserPool.performanceFee() (src/interfaces/IUserPool.sol#242) (function)
IstQEURO.getStakingStats().totalYieldEarned (src/interfaces/IstQEURO.sol#104) shadows:
	- IstQEURO.totalYieldEarned() (src/interfaces/IstQEURO.sol#188) (function)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#local-variable-shadowing

HedgerPool.recoverETH(address).to (src/core/HedgerPool.sol#914) lacks a zero-check on :
		- (success,None) = to.call{value: balance}() (src/core/HedgerPool.sol#921)
QEUROToken.recoverETH(address).to (src/core/QEUROToken.sol#1161) lacks a zero-check on :
		- (success,None) = to.call{value: balance}() (src/core/QEUROToken.sol#1168)
QTIToken.initialize(address,address,address)._treasury (src/core/QTIToken.sol#318) lacks a zero-check on :
		- treasury = _treasury (src/core/QTIToken.sol#334)
QTIToken.updateTreasury(address)._treasury (src/core/QTIToken.sol#928) lacks a zero-check on :
		- treasury = _treasury (src/core/QTIToken.sol#930)
QTIToken.recoverETH(address).to (src/core/QTIToken.sol#1054) lacks a zero-check on :
		- (success,None) = to.call{value: balance}() (src/core/QTIToken.sol#1060)
AaveVault.recoverETH(address).to (src/core/vaults/AaveVault.sol#612) lacks a zero-check on :
		- (success,None) = to.call{value: balance}() (src/core/vaults/AaveVault.sol#618)
YieldShift.recoverETH(address).to (src/core/yieldmanagement/YieldShift.sol#835) lacks a zero-check on :
		- (success,None) = to.call{value: balance}() (src/core/yieldmanagement/YieldShift.sol#841)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation

UserPool.batchDeposit(uint256[],uint256[]) (src/core/UserPool.sol#420-485) has external calls inside a loop: qeuroBefore = qeuro.balanceOf(address(this)) (src/core/UserPool.sol#462)
UserPool.batchDeposit(uint256[],uint256[]) (src/core/UserPool.sol#420-485) has external calls inside a loop: vault.mintQEURO(netAmount,minQeuroOut) (src/core/UserPool.sol#468)
UserPool.batchDeposit(uint256[],uint256[]) (src/core/UserPool.sol#420-485) has external calls inside a loop: qeuroAfter = qeuro.balanceOf(address(this)) (src/core/UserPool.sol#471)
UserPool.batchWithdraw(uint256[],uint256[]) (src/core/UserPool.sol#538-596) has external calls inside a loop: usdcBefore = usdc.balanceOf(address(this)) (src/core/UserPool.sol#571)
UserPool.batchWithdraw(uint256[],uint256[]) (src/core/UserPool.sol#538-596) has external calls inside a loop: vault.redeemQEURO(qeuroAmount,minUsdcOut) (src/core/UserPool.sol#574)
UserPool.batchWithdraw(uint256[],uint256[]) (src/core/UserPool.sol#538-596) has external calls inside a loop: usdcAfter = usdc.balanceOf(address(this)) (src/core/UserPool.sol#577)
UserPool.batchRewardClaim(address[]) (src/core/UserPool.sol#748-776) has external calls inside a loop: qeuro.mint(user,rewardAmount) (src/core/UserPool.sol#771)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation/#calls-inside-a-loop

Reentrancy in UserPool.deposit(uint256,uint256) (src/core/UserPool.sol#366-410):
	External calls:
	- vault.mintQEURO(netAmount,minQeuroOut) (src/core/UserPool.sol#395)
	State variables written after the call(s):
	- totalDeposits += netAmount (src/core/UserPool.sol#404)
Reentrancy in AaveVault.emergencyWithdrawFromAave() (src/core/vaults/AaveVault.sol#503-542):
	External calls:
	- withdrawn = aavePool.withdraw(address(usdc),type()(uint256).max,address(this)) (src/core/vaults/AaveVault.sol#517-540)
	State variables written after the call(s):
	- principalDeposited -= principalWithdrawn (src/core/vaults/AaveVault.sol#531)
Reentrancy in AaveVault.harvestAaveYield() (src/core/vaults/AaveVault.sol#320-367):
	External calls:
	- withdrawn = aavePool.withdraw(address(usdc),availableYield,address(this)) (src/core/vaults/AaveVault.sol#336-366)
	State variables written after the call(s):
	- lastHarvestTime = block.timestamp (src/core/vaults/AaveVault.sol#351)
	- totalFeesCollected += protocolFee (src/core/vaults/AaveVault.sol#350)
	- totalYieldHarvested += actualYieldReceived (src/core/vaults/AaveVault.sol#349)
Reentrancy in QuantillonVault.redeemQEURO(uint256,uint256) (src/core/QuantillonVault.sol#319-362):
	External calls:
	- qeuro.burn(msg.sender,qeuroAmount) (src/core/QuantillonVault.sol#350)
	State variables written after the call(s):
	- totalMinted -= qeuroAmount (src/core/QuantillonVault.sol#355)
Reentrancy in UserPool.withdraw(uint256,uint256) (src/core/UserPool.sol#495-528):
	External calls:
	- vault.redeemQEURO(qeuroAmount,minUsdcOut) (src/core/UserPool.sol#511)
	State variables written after the call(s):
	- totalDeposits -= netAmount (src/core/UserPool.sol#522)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-2

Reentrancy in AaveVault.emergencyWithdrawFromAave() (src/core/vaults/AaveVault.sol#503-542):
	External calls:
	- withdrawn = aavePool.withdraw(address(usdc),type()(uint256).max,address(this)) (src/core/vaults/AaveVault.sol#517-540)
	Event emitted after the call(s):
	- EmergencyModeToggled(Emergency withdrawal executed,true) (src/core/vaults/AaveVault.sol#534)
	- EmergencyWithdrawal(Emergency exit from Aave,amountWithdrawn,block.timestamp) (src/core/vaults/AaveVault.sol#533)
Reentrancy in QTIToken.executeProposal(uint256) (src/core/QTIToken.sol#785-802):
	External calls:
	- (success,None) = address(this).call(proposal.data) (src/core/QTIToken.sol#797)
	Event emitted after the call(s):
	- ProposalExecuted(proposalId) (src/core/QTIToken.sol#801)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-3

HedgerPool.clearExpiredLiquidationCommitment(address,uint256) (src/core/HedgerPool.sol#885-890) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp > lastLiquidationAttempt[hedger] + 3600 (src/core/HedgerPool.sol#887)
QEUROToken._checkAndUpdateMintRateLimit(uint256) (src/core/QEUROToken.sol#516-542) uses timestamp for comparisons
	Dangerous comparisons:
	- timeSinceReset > 86400 (src/core/QEUROToken.sol#522)
	- timeSinceReset >= 3600 (src/core/QEUROToken.sol#526)
	- rateLimitInfo.currentHourMinted + amount > rateLimitCaps.mint (src/core/QEUROToken.sol#534)
QEUROToken._checkAndUpdateBurnRateLimit(uint256) (src/core/QEUROToken.sol#558-584) uses timestamp for comparisons
	Dangerous comparisons:
	- timeSinceReset > 86400 (src/core/QEUROToken.sol#564)
	- timeSinceReset >= 3600 (src/core/QEUROToken.sol#568)
	- rateLimitInfo.currentHourBurned + amount > rateLimitCaps.burn (src/core/QEUROToken.sol#576)
QTIToken.lock(uint256,uint256) (src/core/QTIToken.sol#361-411) uses timestamp for comparisons
	Dangerous comparisons:
	- newUnlockTime > type()(uint32).max (src/core/QTIToken.sol#376)
	- lockInfo.unlockTime > block.timestamp (src/core/QTIToken.sol#379)
	- newUnlockTime > type()(uint32).max (src/core/QTIToken.sol#381)
QTIToken.unlock() (src/core/QTIToken.sol#417-441) uses timestamp for comparisons
	Dangerous comparisons:
	- lockInfo.unlockTime > block.timestamp (src/core/QTIToken.sol#419)
QTIToken.batchLock(uint256[],uint256[]) (src/core/QTIToken.sol#449-529) uses timestamp for comparisons
	Dangerous comparisons:
	- newUnlockTime > type()(uint32).max (src/core/QTIToken.sol#489)
	- lockInfoUnlockTime > currentTimestamp (src/core/QTIToken.sol#492)
	- newUnlockTime > type()(uint32).max (src/core/QTIToken.sol#494)
QTIToken.batchUnlock(address[]) (src/core/QTIToken.sol#536-573) uses timestamp for comparisons
	Dangerous comparisons:
	- lockInfo.unlockTime > currentTimestamp (src/core/QTIToken.sol#551)
QTIToken.getVotingPower(address) (src/core/QTIToken.sol#610-636) uses timestamp for comparisons
	Dangerous comparisons:
	- lockInfo.unlockTime <= block.timestamp || lockInfo.amount == 0 (src/core/QTIToken.sol#614)
	- remainingTime >= originalLockTime (src/core/QTIToken.sol#630)
QTIToken.vote(uint256,bool) (src/core/QTIToken.sol#714-737) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < proposal.startTime (src/core/QTIToken.sol#716)
	- block.timestamp >= proposal.endTime (src/core/QTIToken.sol#717)
QTIToken.batchVote(uint256[],bool[]) (src/core/QTIToken.sol#744-779) uses timestamp for comparisons
	Dangerous comparisons:
	- currentTimestamp < proposal.startTime (src/core/QTIToken.sol#761)
	- currentTimestamp >= proposal.endTime (src/core/QTIToken.sol#762)
QTIToken.executeProposal(uint256) (src/core/QTIToken.sol#785-802) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < proposal.endTime (src/core/QTIToken.sol#787)
QTIToken.getProposalExecutionInfo(uint256) (src/core/QTIToken.sol#811-819) uses timestamp for comparisons
	Dangerous comparisons:
	- canExecute = scheduled && block.timestamp >= executionTime (src/core/QTIToken.sol#818)
QTIToken.updateDecentralizationLevel() (src/core/QTIToken.sol#941-955) uses timestamp for comparisons
	Dangerous comparisons:
	- timeElapsed > MAX_TIME_ELAPSED (src/core/QTIToken.sol#945)
	- newLevel > 10000 (src/core/QTIToken.sol#951)
QTIToken._updateVotingPower(address) (src/core/QTIToken.sol#978-1007) uses timestamp for comparisons
	Dangerous comparisons:
	- lockInfo.unlockTime <= block.timestamp || lockInfo.amount == 0 (src/core/QTIToken.sol#982)
	- remainingTime >= originalLockTime (src/core/QTIToken.sol#990)
	- newVotingPower > type()(uint96).max (src/core/QTIToken.sol#1000)
TimelockUpgradeable.proposeUpgrade(address,string,uint256) (src/core/TimelockUpgradeable.sol#146-170) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(pendingUpgrades[newImplementation].implementation == address(0),TimelockUpgradeable: Already proposed) (src/core/TimelockUpgradeable.sol#152)
TimelockUpgradeable.approveUpgrade(address) (src/core/TimelockUpgradeable.sol#176-185) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(upgrade.implementation != address(0),TimelockUpgradeable: No pending upgrade) (src/core/TimelockUpgradeable.sol#178)
TimelockUpgradeable.executeUpgrade(address) (src/core/TimelockUpgradeable.sol#204-220) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(upgrade.implementation != address(0),TimelockUpgradeable: No pending upgrade) (src/core/TimelockUpgradeable.sol#206)
	- require(bool,string)(block.timestamp >= upgrade.executableAt,TimelockUpgradeable: Timelock not expired) (src/core/TimelockUpgradeable.sol#207)
TimelockUpgradeable.cancelUpgrade(address) (src/core/TimelockUpgradeable.sol#226-238) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(upgrade.implementation != address(0),TimelockUpgradeable: No pending upgrade) (src/core/TimelockUpgradeable.sol#228)
	- require(bool,string)(msg.sender == upgrade.proposer || hasRole(DEFAULT_ADMIN_ROLE,msg.sender),TimelockUpgradeable: Not authorized) (src/core/TimelockUpgradeable.sol#229-232)
TimelockUpgradeable.canExecuteUpgrade(address) (src/core/TimelockUpgradeable.sol#332-340) uses timestamp for comparisons
	Dangerous comparisons:
	- (block.timestamp >= upgrade.executableAt && upgradeApprovalCount[implementation] >= MIN_MULTISIG_APPROVALS) (src/core/TimelockUpgradeable.sol#336-339)
UserPool.withdraw(uint256,uint256) (src/core/UserPool.sol#495-528) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(user.qeuroBalance >= qeuroAmount,UserPool: Insufficient balance) (src/core/UserPool.sol#505)
UserPool.batchWithdraw(uint256[],uint256[]) (src/core/UserPool.sol#538-596) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(user.qeuroBalance >= totalQeuroAmount,UserPool: Insufficient balance) (src/core/UserPool.sol#556)
UserPool.requestUnstake(uint256) (src/core/UserPool.sol#678-688) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(user.stakedAmount >= qeuroAmount,UserPool: Insufficient staked amount) (src/core/UserPool.sol#680)
UserPool.unstake() (src/core/UserPool.sol#695-717) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(user.unstakeAmount > 0,UserPool: No unstaking request) (src/core/UserPool.sol#697)
	- require(bool,string)(block.timestamp >= user.unstakeRequestTime + unstakingCooldown,UserPool: Cooldown period not finished) (src/core/UserPool.sol#698-701)
stQEUROToken._calculateCurrentExchangeRate() (src/core/stQEUROToken.sol#621-651) uses timestamp for comparisons
	Dangerous comparisons:
	- pendingYield >= minYieldThreshold || block.timestamp >= lastUpdateTime + maxUpdateFrequency (src/core/stQEUROToken.sol#630-631)
YieldShift.claimUserYield(address) (src/core/yieldmanagement/YieldShift.sol#325-353) uses timestamp for comparisons
	Dangerous comparisons:
	- block.timestamp < lastDepositTime[user] + MIN_HOLDING_PERIOD (src/core/yieldmanagement/YieldShift.sol#338)
YieldShift.getHistoricalYieldShift(uint256) (src/core/yieldmanagement/YieldShift.sol#512-568) uses timestamp for comparisons
	Dangerous comparisons:
	- snapshot.timestamp >= cutoffTime (src/core/yieldmanagement/YieldShift.sol#534)
	- block.timestamp > period (src/core/yieldmanagement/YieldShift.sol#523-524)
YieldShift.checkAndUpdateYieldDistribution() (src/core/yieldmanagement/YieldShift.sol#726-745) uses timestamp for comparisons
	Dangerous comparisons:
	- timeSinceUpdate > MAX_TIME_ELAPSED (src/core/yieldmanagement/YieldShift.sol#729)
	- timeCondition = timeSinceUpdate >= TWAP_PERIOD (src/core/yieldmanagement/YieldShift.sol#733)
	- timeCondition || imbalanceCondition (src/core/yieldmanagement/YieldShift.sol#742)
YieldShift.getTimeWeightedAverage(YieldShift.PoolSnapshot[],uint256,bool) (src/core/yieldmanagement/YieldShift.sol#752-799) uses timestamp for comparisons
	Dangerous comparisons:
	- timestamp >= cutoffTime (src/core/yieldmanagement/YieldShift.sol#777)
	- totalWeight == 0 (src/core/yieldmanagement/YieldShift.sol#792)
	- block.timestamp > period (src/core/yieldmanagement/YieldShift.sol#762-763)
ChainlinkOracle._validateTimestamp(uint256) (src/oracle/ChainlinkOracle.sol#236-246) uses timestamp for comparisons
	Dangerous comparisons:
	- reportedTime > block.timestamp (src/oracle/ChainlinkOracle.sol#238)
	- block.timestamp > reportedTime + maxAllowedAge (src/oracle/ChainlinkOracle.sol#243)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp

HedgerPool._closeSinglePosition(uint256,uint256,HedgerPool.HedgerInfo) (src/core/HedgerPool.sol#428-467) has costly operations inside a loop:
	- totalMargin -= positionMargin (src/core/HedgerPool.sol#453)
	Calls stack containing the loop:
		HedgerPool.closePositionsBatch(uint256[],uint256)
HedgerPool._closeSinglePosition(uint256,uint256,HedgerPool.HedgerInfo) (src/core/HedgerPool.sol#428-467) has costly operations inside a loop:
	- totalExposure -= positionSize (src/core/HedgerPool.sol#454)
	Calls stack containing the loop:
		HedgerPool.closePositionsBatch(uint256[],uint256)
QTIToken.batchUnlock(address[]) (src/core/QTIToken.sol#536-573) has costly operations inside a loop:
	- totalLocked = totalLocked - amount (src/core/QTIToken.sol#564)
QTIToken.batchUnlock(address[]) (src/core/QTIToken.sol#536-573) has costly operations inside a loop:
	- totalVotingPower = totalVotingPower - oldVotingPower (src/core/QTIToken.sol#565)
UserPool.batchDeposit(uint256[],uint256[]) (src/core/UserPool.sol#420-485) has costly operations inside a loop:
	- totalDeposits += netAmount (src/core/UserPool.sol#478)
UserPool.batchWithdraw(uint256[],uint256[]) (src/core/UserPool.sol#538-596) has costly operations inside a loop:
	- totalDeposits -= netAmount (src/core/UserPool.sol#589)
UserPool.batchStake(uint256[]) (src/core/UserPool.sol#635-670) has costly operations inside a loop:
	- totalStakes += qeuroAmount (src/core/UserPool.sol#666)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#costly-operations-inside-a-loop

QTIToken.batchLock(uint256[],uint256[]) (src/core/QTIToken.sol#449-529) has a high cyclomatic complexity (16).
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#cyclomatic-complexity

Low level call in HedgerPool.recoverETH(address) (src/core/HedgerPool.sol#914-923):
	- (success,None) = to.call{value: balance}() (src/core/HedgerPool.sol#921)
Low level call in QEUROToken.recoverETH(address) (src/core/QEUROToken.sol#1161-1170):
	- (success,None) = to.call{value: balance}() (src/core/QEUROToken.sol#1168)
Low level call in QTIToken.executeProposal(uint256) (src/core/QTIToken.sol#785-802):
	- (success,None) = address(this).call(proposal.data) (src/core/QTIToken.sol#797)
Low level call in QTIToken.recoverETH(address) (src/core/QTIToken.sol#1054-1062):
	- (success,None) = to.call{value: balance}() (src/core/QTIToken.sol#1060)
Low level call in QuantillonVault.recoverETH(address) (src/core/QuantillonVault.sol#582-591):
	- (success,None) = to.call{value: balance}() (src/core/QuantillonVault.sol#589)
Low level call in UserPool.recoverETH(address) (src/core/UserPool.sol#1134-1142):
	- (success,None) = to.call{value: balance}() (src/core/UserPool.sol#1140)
Low level call in stQEUROToken.recoverETH(address) (src/core/stQEUROToken.sol#744-753):
	- (success,None) = to.call{value: balance}() (src/core/stQEUROToken.sol#751)
Low level call in AaveVault.recoverETH(address) (src/core/vaults/AaveVault.sol#612-620):
	- (success,None) = to.call{value: balance}() (src/core/vaults/AaveVault.sol#618)
Low level call in YieldShift.recoverETH(address) (src/core/yieldmanagement/YieldShift.sol#835-843):
	- (success,None) = to.call{value: balance}() (src/core/yieldmanagement/YieldShift.sol#841)
Low level call in ChainlinkOracle.recoverETH(address) (src/oracle/ChainlinkOracle.sol#638-647):
	- (success,None) = to.call{value: balance}() (src/oracle/ChainlinkOracle.sol#645)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls

ChainlinkOracle (src/oracle/ChainlinkOracle.sol#41-835) should inherit from IChainlinkOracle (src/interfaces/IChainlinkOracle.sol#11-155)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#missing-inheritance

QuantillonVault.lastValidEurUsdPrice (src/core/QuantillonVault.sol#602) is never used in QuantillonVault (src/core/QuantillonVault.sol#72-605)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#unused-state-variable

HedgerPool.interestDifferentialPool (src/core/HedgerPool.sol#166) should be constant 
HedgerPool.totalYieldEarned (src/core/HedgerPool.sol#165) should be constant 
QuantillonVault.lastValidEurUsdPrice (src/core/QuantillonVault.sol#602) should be constant 
UserPool.accumulatedYieldPerShare (src/core/UserPool.sol#219) should be constant 
UserPool.lastYieldDistribution (src/core/UserPool.sol#224) should be constant 
UserPool.totalYieldDistributed (src/core/UserPool.sol#229) should be constant 
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant
**THIS CHECKLIST IS NOT COMPLETE**. Use `--show-ignored-findings` to show all the results.
Summary
 - [arbitrary-send-erc20](#arbitrary-send-erc20) (1 results) (High)
 - [arbitrary-send-eth](#arbitrary-send-eth) (9 results) (High)
 - [uninitialized-state](#uninitialized-state) (5 results) (High)
 - [incorrect-equality](#incorrect-equality) (11 results) (Medium)
 - [reentrancy-no-eth](#reentrancy-no-eth) (8 results) (Medium)
 - [unused-return](#unused-return) (16 results) (Medium)
 - [shadowing-local](#shadowing-local) (29 results) (Low)
 - [missing-zero-check](#missing-zero-check) (7 results) (Low)
 - [calls-loop](#calls-loop) (7 results) (Low)
 - [reentrancy-benign](#reentrancy-benign) (5 results) (Low)
 - [reentrancy-events](#reentrancy-events) (2 results) (Low)
 - [timestamp](#timestamp) (29 results) (Low)
 - [costly-loop](#costly-loop) (7 results) (Informational)
 - [cyclomatic-complexity](#cyclomatic-complexity) (1 results) (Informational)
 - [low-level-calls](#low-level-calls) (10 results) (Informational)
 - [missing-inheritance](#missing-inheritance) (1 results) (Informational)
 - [unused-state](#unused-state) (1 results) (Informational)
 - [constable-states](#constable-states) (6 results) (Optimization)
## arbitrary-send-erc20
Impact: High
Confidence: High
 - [ ] ID-0
[YieldShift.harvestAndDistributeAaveYield()](src/core/yieldmanagement/YieldShift.sol#L715-L724) uses arbitrary from in transferFrom: [usdc.safeTransferFrom(address(aaveVault),address(this),yieldHarvested)](src/core/yieldmanagement/YieldShift.sol#L719)

src/core/yieldmanagement/YieldShift.sol#L715-L724


## arbitrary-send-eth
Impact: High
Confidence: Medium
 - [ ] ID-1
[QTIToken.recoverETH(address)](src/core/QTIToken.sol#L1054-L1062) sends eth to arbitrary user
	Dangerous calls:
	- [(success,None) = to.call{value: balance}()](src/core/QTIToken.sol#L1060)

src/core/QTIToken.sol#L1054-L1062


 - [ ] ID-2
[YieldShift.recoverETH(address)](src/core/yieldmanagement/YieldShift.sol#L835-L843) sends eth to arbitrary user
	Dangerous calls:
	- [(success,None) = to.call{value: balance}()](src/core/yieldmanagement/YieldShift.sol#L841)

src/core/yieldmanagement/YieldShift.sol#L835-L843


 - [ ] ID-3
[ChainlinkOracle.recoverETH(address)](src/oracle/ChainlinkOracle.sol#L638-L647) sends eth to arbitrary user
	Dangerous calls:
	- [(success,None) = to.call{value: balance}()](src/oracle/ChainlinkOracle.sol#L645)

src/oracle/ChainlinkOracle.sol#L638-L647


 - [ ] ID-4
[HedgerPool.recoverETH(address)](src/core/HedgerPool.sol#L914-L923) sends eth to arbitrary user
	Dangerous calls:
	- [(success,None) = to.call{value: balance}()](src/core/HedgerPool.sol#L921)

src/core/HedgerPool.sol#L914-L923


 - [ ] ID-5
[QuantillonVault.recoverETH(address)](src/core/QuantillonVault.sol#L582-L591) sends eth to arbitrary user
	Dangerous calls:
	- [(success,None) = to.call{value: balance}()](src/core/QuantillonVault.sol#L589)

src/core/QuantillonVault.sol#L582-L591


**More results were found, check [10](10)**
## uninitialized-state
Impact: High
Confidence: High
 - [ ] ID-6
[UserPool.accumulatedYieldPerShare](src/core/UserPool.sol#L219) is never initialized. It is used in:
	- [UserPool._updatePendingRewards(address)](src/core/UserPool.sol#L804-L843)
	- [UserPool.getUserPendingRewards(address)](src/core/UserPool.sol#L872-L901)

src/core/UserPool.sol#L219


 - [ ] ID-7
[QTIToken.proposalExecutionHash](src/core/QTIToken.sol#L229) is never initialized. It is used in:
	- [QTIToken.getProposalExecutionHash(uint256)](src/core/QTIToken.sol#L826-L828)

src/core/QTIToken.sol#L229


 - [ ] ID-8
[QTIToken.proposalExecutionTime](src/core/QTIToken.sol#L227) is never initialized. It is used in:
	- [QTIToken.getProposalExecutionInfo(uint256)](src/core/QTIToken.sol#L811-L819)

src/core/QTIToken.sol#L227


 - [ ] ID-9
[YieldShift.yieldShiftHistory](src/core/yieldmanagement/YieldShift.sol#L158) is never initialized. It is used in:
	- [YieldShift.getHistoricalYieldShift(uint256)](src/core/yieldmanagement/YieldShift.sol#L512-L568)

src/core/yieldmanagement/YieldShift.sol#L158


 - [ ] ID-10
[QTIToken.proposalScheduled](src/core/QTIToken.sol#L231) is never initialized. It is used in:
	- [QTIToken.getProposalExecutionInfo(uint256)](src/core/QTIToken.sol#L811-L819)

src/core/QTIToken.sol#L231


## incorrect-equality
Impact: Medium
Confidence: High
 - [ ] ID-11
[UserPool._updatePendingRewards(address)](src/core/UserPool.sol#L804-L843) uses a dangerous strict equality:
	- [lastRewardBlock == 0](src/core/UserPool.sol#L812)

src/core/UserPool.sol#L804-L843


 - [ ] ID-12
[QTIToken.recoverETH(address)](src/core/QTIToken.sol#L1054-L1062) uses a dangerous strict equality:
	- [balance == 0](src/core/QTIToken.sol#L1057)

src/core/QTIToken.sol#L1054-L1062


 - [ ] ID-13
[HedgerPool._updateHedgerRewards(address)](src/core/HedgerPool.sol#L660-L692) uses a dangerous strict equality:
	- [lastRewardBlock == 0](src/core/HedgerPool.sol#L667)

src/core/HedgerPool.sol#L660-L692


 - [ ] ID-14
[AaveVault.recoverETH(address)](src/core/vaults/AaveVault.sol#L612-L620) uses a dangerous strict equality:
	- [balance == 0](src/core/vaults/AaveVault.sol#L616)

src/core/vaults/AaveVault.sol#L612-L620


 - [ ] ID-15
[HedgerPool.recoverETH(address)](src/core/HedgerPool.sol#L914-L923) uses a dangerous strict equality:
	- [balance == 0](src/core/HedgerPool.sol#L919)

src/core/HedgerPool.sol#L914-L923


**More results were found, check [10](10)**
## reentrancy-no-eth
Impact: Medium
Confidence: Medium
 - [ ] ID-16
Reentrancy in [UserPool.batchDeposit(uint256[],uint256[])](src/core/UserPool.sol#L420-L485):
	External calls:
	- [vault.mintQEURO(netAmount,minQeuroOut)](src/core/UserPool.sol#L468)
	State variables written after the call(s):
	- [totalDeposits += netAmount](src/core/UserPool.sol#L478)
	[UserPool.totalDeposits](src/core/UserPool.sol#L173) can be used in cross function reentrancies:
	- [UserPool.getPoolMetrics()](src/core/UserPool.sol#L952-L962)
	- [UserPool.getTotalDeposits()](src/core/UserPool.sol#L933-L935)
	- [UserPool.totalDeposits](src/core/UserPool.sol#L173)
	- [user.qeuroBalance += uint128(qeuroMinted)](src/core/UserPool.sol#L476)
	[UserPool.userInfo](src/core/UserPool.sol#L208) can be used in cross function reentrancies:
	- [UserPool.emergencyUnstake(address)](src/core/UserPool.sol#L1054-L1064)
	- [UserPool.getUserDeposits(address)](src/core/UserPool.sol#L854-L856)
	- [UserPool.getUserInfo(address)](src/core/UserPool.sol#L912-L927)
	- [UserPool.getUserPendingRewards(address)](src/core/UserPool.sol#L872-L901)
	- [UserPool.getUserStakes(address)](src/core/UserPool.sol#L863-L865)
	- [UserPool.userInfo](src/core/UserPool.sol#L208)
	- [user.depositHistory += uint96(usdcAmount)](src/core/UserPool.sol#L477)
	[UserPool.userInfo](src/core/UserPool.sol#L208) can be used in cross function reentrancies:
	- [UserPool.emergencyUnstake(address)](src/core/UserPool.sol#L1054-L1064)
	- [UserPool.getUserDeposits(address)](src/core/UserPool.sol#L854-L856)
	- [UserPool.getUserInfo(address)](src/core/UserPool.sol#L912-L927)
	- [UserPool.getUserPendingRewards(address)](src/core/UserPool.sol#L872-L901)
	- [UserPool.getUserStakes(address)](src/core/UserPool.sol#L863-L865)
	- [UserPool.userInfo](src/core/UserPool.sol#L208)

src/core/UserPool.sol#L420-L485


 - [ ] ID-17
Reentrancy in [QuantillonVault.redeemQEURO(uint256,uint256)](src/core/QuantillonVault.sol#L319-L362):
	External calls:
	- [qeuro.burn(msg.sender,qeuroAmount)](src/core/QuantillonVault.sol#L350)
	State variables written after the call(s):
	- [totalUsdcHeld -= usdcToReturn](src/core/QuantillonVault.sol#L354)
	[QuantillonVault.totalUsdcHeld](src/core/QuantillonVault.sol#L141) can be used in cross function reentrancies:
	- [QuantillonVault.getVaultMetrics()](src/core/QuantillonVault.sol#L379-L398)
	- [QuantillonVault.totalUsdcHeld](src/core/QuantillonVault.sol#L141)
	- [QuantillonVault.withdrawProtocolFees(address)](src/core/QuantillonVault.sol#L487-L496)

src/core/QuantillonVault.sol#L319-L362


 - [ ] ID-18
Reentrancy in [UserPool.deposit(uint256,uint256)](src/core/UserPool.sol#L366-L410):
	External calls:
	- [vault.mintQEURO(netAmount,minQeuroOut)](src/core/UserPool.sol#L395)
	State variables written after the call(s):
	- [user.qeuroBalance += uint128(qeuroMinted)](src/core/UserPool.sol#L402)
	[UserPool.userInfo](src/core/UserPool.sol#L208) can be used in cross function reentrancies:
	- [UserPool.emergencyUnstake(address)](src/core/UserPool.sol#L1054-L1064)
	- [UserPool.getUserDeposits(address)](src/core/UserPool.sol#L854-L856)
	- [UserPool.getUserInfo(address)](src/core/UserPool.sol#L912-L927)
	- [UserPool.getUserPendingRewards(address)](src/core/UserPool.sol#L872-L901)
	- [UserPool.getUserStakes(address)](src/core/UserPool.sol#L863-L865)
	- [UserPool.userInfo](src/core/UserPool.sol#L208)
	- [user.depositHistory += uint96(usdcAmount)](src/core/UserPool.sol#L403)
	[UserPool.userInfo](src/core/UserPool.sol#L208) can be used in cross function reentrancies:
	- [UserPool.emergencyUnstake(address)](src/core/UserPool.sol#L1054-L1064)
	- [UserPool.getUserDeposits(address)](src/core/UserPool.sol#L854-L856)
	- [UserPool.getUserInfo(address)](src/core/UserPool.sol#L912-L927)
	- [UserPool.getUserPendingRewards(address)](src/core/UserPool.sol#L872-L901)
	- [UserPool.getUserStakes(address)](src/core/UserPool.sol#L863-L865)
	- [UserPool.userInfo](src/core/UserPool.sol#L208)

src/core/UserPool.sol#L366-L410


 - [ ] ID-19
Reentrancy in [AaveVault.deployToAave(uint256)](src/core/vaults/AaveVault.sol#L212-L239):
	External calls:
	- [aavePool.supply(address(usdc),amount,address(this),0)](src/core/vaults/AaveVault.sol#L231)
	State variables written after the call(s):
	- [principalDeposited += amount](src/core/vaults/AaveVault.sol#L236)
	[AaveVault.principalDeposited](src/core/vaults/AaveVault.sol#L147) can be used in cross function reentrancies:
	- [AaveVault.emergencyWithdrawFromAave()](src/core/vaults/AaveVault.sol#L503-L542)
	- [AaveVault.getAavePositionDetails()](src/core/vaults/AaveVault.sol#L406-L416)
	- [AaveVault.getAvailableYield()](src/core/vaults/AaveVault.sol#L369-L377)
	- [AaveVault.principalDeposited](src/core/vaults/AaveVault.sol#L147)

src/core/vaults/AaveVault.sol#L212-L239


 - [ ] ID-20
Reentrancy in [UserPool.batchWithdraw(uint256[],uint256[])](src/core/UserPool.sol#L538-L596):
	External calls:
	- [vault.redeemQEURO(qeuroAmount,minUsdcOut)](src/core/UserPool.sol#L574)
	State variables written after the call(s):
	- [totalDeposits -= netAmount](src/core/UserPool.sol#L589)
	[UserPool.totalDeposits](src/core/UserPool.sol#L173) can be used in cross function reentrancies:
	- [UserPool.getPoolMetrics()](src/core/UserPool.sol#L952-L962)
	- [UserPool.getTotalDeposits()](src/core/UserPool.sol#L933-L935)
	- [UserPool.totalDeposits](src/core/UserPool.sol#L173)
	- [user.qeuroBalance -= uint128(qeuroAmount)](src/core/UserPool.sol#L586)
	[UserPool.userInfo](src/core/UserPool.sol#L208) can be used in cross function reentrancies:
	- [UserPool.emergencyUnstake(address)](src/core/UserPool.sol#L1054-L1064)
	- [UserPool.getUserDeposits(address)](src/core/UserPool.sol#L854-L856)
	- [UserPool.getUserInfo(address)](src/core/UserPool.sol#L912-L927)
	- [UserPool.getUserPendingRewards(address)](src/core/UserPool.sol#L872-L901)
	- [UserPool.getUserStakes(address)](src/core/UserPool.sol#L863-L865)
	- [UserPool.userInfo](src/core/UserPool.sol#L208)

src/core/UserPool.sol#L538-L596


**More results were found, check [10](10)**
## unused-return
Impact: Medium
Confidence: Medium
 - [ ] ID-21
[YieldShift.getYieldPerformanceMetrics()](src/core/yieldmanagement/YieldShift.sol#L570-L588) ignores return value by [(totalUsers,None,None,None) = userPool.getPoolMetrics()](src/core/yieldmanagement/YieldShift.sol#L578)

src/core/yieldmanagement/YieldShift.sol#L570-L588


 - [ ] ID-22
[ChainlinkOracle._updatePrices()](src/oracle/ChainlinkOracle.sol#L253-L320) ignores return value by [(None,usdcUsdRawPrice,None,usdcUsdUpdatedAt,None) = usdcUsdPriceFeed.latestRoundData()](src/oracle/ChainlinkOracle.sol#L258)

src/oracle/ChainlinkOracle.sol#L253-L320


 - [ ] ID-23
[ChainlinkOracle.getOracleHealth()](src/oracle/ChainlinkOracle.sol#L363-L406) ignores return value by [(updatedAt) = eurUsdPriceFeed.latestRoundData()](src/oracle/ChainlinkOracle.sol#L373-L383)

src/oracle/ChainlinkOracle.sol#L363-L406


 - [ ] ID-24
[AaveVault.autoRebalance()](src/core/vaults/AaveVault.sol#L452-L475) ignores return value by [(optimalAllocation,None) = this.calculateOptimalAllocation()](src/core/vaults/AaveVault.sol#L458)

src/core/vaults/AaveVault.sol#L452-L475


 - [ ] ID-25
[ChainlinkOracle.getOracleHealth()](src/oracle/ChainlinkOracle.sol#L363-L406) ignores return value by [(updatedAt_scope_0) = usdcUsdPriceFeed.latestRoundData()](src/oracle/ChainlinkOracle.sol#L386-L396)

src/oracle/ChainlinkOracle.sol#L363-L406


**More results were found, check [10](10)**
## shadowing-local
Impact: Low
Confidence: High
 - [ ] ID-26
[IQTIToken.getGovernanceInfo().totalVotingPower](src/interfaces/IQTIToken.sol#L199) shadows:
	- [IQTIToken.totalVotingPower()](src/interfaces/IQTIToken.sol#L253) (function)

src/interfaces/IQTIToken.sol#L199


 - [ ] ID-27
[IQTIToken.getGovernanceInfo().currentDecentralizationLevel](src/interfaces/IQTIToken.sol#L202) shadows:
	- [IQTIToken.currentDecentralizationLevel()](src/interfaces/IQTIToken.sol#L272) (function)

src/interfaces/IQTIToken.sol#L202


 - [ ] ID-28
[IHedgerPool.getHedgingConfig().exitFee](src/interfaces/IHedgerPool.sol#L59) shadows:
	- [IHedgerPool.exitFee()](src/interfaces/IHedgerPool.sol#L81) (function)

src/interfaces/IHedgerPool.sol#L59


 - [ ] ID-29
[IstQEURO.getStakingStats().totalYieldEarned](src/interfaces/IstQEURO.sol#L104) shadows:
	- [IstQEURO.totalYieldEarned()](src/interfaces/IstQEURO.sol#L188) (function)

src/interfaces/IstQEURO.sol#L104


 - [ ] ID-30
[IUserPool.getPoolConfig().unstakingCooldown](src/interfaces/IUserPool.sol#L199) shadows:
	- [IUserPool.unstakingCooldown()](src/interfaces/IUserPool.sol#L239) (function)

src/interfaces/IUserPool.sol#L199


**More results were found, check [10](10)**
## missing-zero-check
Impact: Low
Confidence: Medium
 - [ ] ID-31
[HedgerPool.recoverETH(address).to](src/core/HedgerPool.sol#L914) lacks a zero-check on :
		- [(success,None) = to.call{value: balance}()](src/core/HedgerPool.sol#L921)

src/core/HedgerPool.sol#L914


 - [ ] ID-32
[QEUROToken.recoverETH(address).to](src/core/QEUROToken.sol#L1161) lacks a zero-check on :
		- [(success,None) = to.call{value: balance}()](src/core/QEUROToken.sol#L1168)

src/core/QEUROToken.sol#L1161


 - [ ] ID-33
[QTIToken.recoverETH(address).to](src/core/QTIToken.sol#L1054) lacks a zero-check on :
		- [(success,None) = to.call{value: balance}()](src/core/QTIToken.sol#L1060)

src/core/QTIToken.sol#L1054


 - [ ] ID-34
[QTIToken.updateTreasury(address)._treasury](src/core/QTIToken.sol#L928) lacks a zero-check on :
		- [treasury = _treasury](src/core/QTIToken.sol#L930)

src/core/QTIToken.sol#L928


 - [ ] ID-35
[YieldShift.recoverETH(address).to](src/core/yieldmanagement/YieldShift.sol#L835) lacks a zero-check on :
		- [(success,None) = to.call{value: balance}()](src/core/yieldmanagement/YieldShift.sol#L841)

src/core/yieldmanagement/YieldShift.sol#L835


**More results were found, check [10](10)**
## calls-loop
Impact: Low
Confidence: Medium
 - [ ] ID-36
[UserPool.batchRewardClaim(address[])](src/core/UserPool.sol#L748-L776) has external calls inside a loop: [qeuro.mint(user,rewardAmount)](src/core/UserPool.sol#L771)

src/core/UserPool.sol#L748-L776


 - [ ] ID-37
[UserPool.batchWithdraw(uint256[],uint256[])](src/core/UserPool.sol#L538-L596) has external calls inside a loop: [usdcAfter = usdc.balanceOf(address(this))](src/core/UserPool.sol#L577)

src/core/UserPool.sol#L538-L596


 - [ ] ID-38
[UserPool.batchDeposit(uint256[],uint256[])](src/core/UserPool.sol#L420-L485) has external calls inside a loop: [qeuroAfter = qeuro.balanceOf(address(this))](src/core/UserPool.sol#L471)

src/core/UserPool.sol#L420-L485


 - [ ] ID-39
[UserPool.batchWithdraw(uint256[],uint256[])](src/core/UserPool.sol#L538-L596) has external calls inside a loop: [vault.redeemQEURO(qeuroAmount,minUsdcOut)](src/core/UserPool.sol#L574)

src/core/UserPool.sol#L538-L596


 - [ ] ID-40
[UserPool.batchWithdraw(uint256[],uint256[])](src/core/UserPool.sol#L538-L596) has external calls inside a loop: [usdcBefore = usdc.balanceOf(address(this))](src/core/UserPool.sol#L571)

src/core/UserPool.sol#L538-L596


**More results were found, check [10](10)**
## reentrancy-benign
Impact: Low
Confidence: Medium
 - [ ] ID-41
Reentrancy in [AaveVault.harvestAaveYield()](src/core/vaults/AaveVault.sol#L320-L367):
	External calls:
	- [withdrawn = aavePool.withdraw(address(usdc),availableYield,address(this))](src/core/vaults/AaveVault.sol#L336-L366)
	State variables written after the call(s):
	- [lastHarvestTime = block.timestamp](src/core/vaults/AaveVault.sol#L351)
	- [totalFeesCollected += protocolFee](src/core/vaults/AaveVault.sol#L350)
	- [totalYieldHarvested += actualYieldReceived](src/core/vaults/AaveVault.sol#L349)

src/core/vaults/AaveVault.sol#L320-L367


 - [ ] ID-42
Reentrancy in [QuantillonVault.redeemQEURO(uint256,uint256)](src/core/QuantillonVault.sol#L319-L362):
	External calls:
	- [qeuro.burn(msg.sender,qeuroAmount)](src/core/QuantillonVault.sol#L350)
	State variables written after the call(s):
	- [totalMinted -= qeuroAmount](src/core/QuantillonVault.sol#L355)

src/core/QuantillonVault.sol#L319-L362


 - [ ] ID-43
Reentrancy in [AaveVault.emergencyWithdrawFromAave()](src/core/vaults/AaveVault.sol#L503-L542):
	External calls:
	- [withdrawn = aavePool.withdraw(address(usdc),type()(uint256).max,address(this))](src/core/vaults/AaveVault.sol#L517-L540)
	State variables written after the call(s):
	- [principalDeposited -= principalWithdrawn](src/core/vaults/AaveVault.sol#L531)

src/core/vaults/AaveVault.sol#L503-L542


 - [ ] ID-44
Reentrancy in [UserPool.deposit(uint256,uint256)](src/core/UserPool.sol#L366-L410):
	External calls:
	- [vault.mintQEURO(netAmount,minQeuroOut)](src/core/UserPool.sol#L395)
	State variables written after the call(s):
	- [totalDeposits += netAmount](src/core/UserPool.sol#L404)

src/core/UserPool.sol#L366-L410


 - [ ] ID-45
Reentrancy in [UserPool.withdraw(uint256,uint256)](src/core/UserPool.sol#L495-L528):
	External calls:
	- [vault.redeemQEURO(qeuroAmount,minUsdcOut)](src/core/UserPool.sol#L511)
	State variables written after the call(s):
	- [totalDeposits -= netAmount](src/core/UserPool.sol#L522)

src/core/UserPool.sol#L495-L528


## reentrancy-events
Impact: Low
Confidence: Medium
 - [ ] ID-46
Reentrancy in [AaveVault.emergencyWithdrawFromAave()](src/core/vaults/AaveVault.sol#L503-L542):
	External calls:
	- [withdrawn = aavePool.withdraw(address(usdc),type()(uint256).max,address(this))](src/core/vaults/AaveVault.sol#L517-L540)
	Event emitted after the call(s):
	- [EmergencyModeToggled(Emergency withdrawal executed,true)](src/core/vaults/AaveVault.sol#L534)
	- [EmergencyWithdrawal(Emergency exit from Aave,amountWithdrawn,block.timestamp)](src/core/vaults/AaveVault.sol#L533)

src/core/vaults/AaveVault.sol#L503-L542


 - [ ] ID-47
Reentrancy in [QTIToken.executeProposal(uint256)](src/core/QTIToken.sol#L785-L802):
	External calls:
	- [(success,None) = address(this).call(proposal.data)](src/core/QTIToken.sol#L797)
	Event emitted after the call(s):
	- [ProposalExecuted(proposalId)](src/core/QTIToken.sol#L801)

src/core/QTIToken.sol#L785-L802


## timestamp
Impact: Low
Confidence: Medium
 - [ ] ID-48
[YieldShift.getTimeWeightedAverage(YieldShift.PoolSnapshot[],uint256,bool)](src/core/yieldmanagement/YieldShift.sol#L752-L799) uses timestamp for comparisons
	Dangerous comparisons:
	- [timestamp >= cutoffTime](src/core/yieldmanagement/YieldShift.sol#L777)
	- [totalWeight == 0](src/core/yieldmanagement/YieldShift.sol#L792)
	- [block.timestamp > period](src/core/yieldmanagement/YieldShift.sol#L762-L763)

src/core/yieldmanagement/YieldShift.sol#L752-L799


 - [ ] ID-49
[stQEUROToken._calculateCurrentExchangeRate()](src/core/stQEUROToken.sol#L621-L651) uses timestamp for comparisons
	Dangerous comparisons:
	- [pendingYield >= minYieldThreshold || block.timestamp >= lastUpdateTime + maxUpdateFrequency](src/core/stQEUROToken.sol#L630-L631)

src/core/stQEUROToken.sol#L621-L651


 - [ ] ID-50
[YieldShift.getHistoricalYieldShift(uint256)](src/core/yieldmanagement/YieldShift.sol#L512-L568) uses timestamp for comparisons
	Dangerous comparisons:
	- [snapshot.timestamp >= cutoffTime](src/core/yieldmanagement/YieldShift.sol#L534)
	- [block.timestamp > period](src/core/yieldmanagement/YieldShift.sol#L523-L524)

src/core/yieldmanagement/YieldShift.sol#L512-L568


 - [ ] ID-51
[TimelockUpgradeable.canExecuteUpgrade(address)](src/core/TimelockUpgradeable.sol#L332-L340) uses timestamp for comparisons
	Dangerous comparisons:
	- [(block.timestamp >= upgrade.executableAt && upgradeApprovalCount[implementation] >= MIN_MULTISIG_APPROVALS)](src/core/TimelockUpgradeable.sol#L336-L339)

src/core/TimelockUpgradeable.sol#L332-L340


 - [ ] ID-52
[YieldShift.checkAndUpdateYieldDistribution()](src/core/yieldmanagement/YieldShift.sol#L726-L745) uses timestamp for comparisons
	Dangerous comparisons:
	- [timeSinceUpdate > MAX_TIME_ELAPSED](src/core/yieldmanagement/YieldShift.sol#L729)
	- [timeCondition = timeSinceUpdate >= TWAP_PERIOD](src/core/yieldmanagement/YieldShift.sol#L733)
	- [timeCondition || imbalanceCondition](src/core/yieldmanagement/YieldShift.sol#L742)

src/core/yieldmanagement/YieldShift.sol#L726-L745


**More results were found, check [10](10)**
## costly-loop
Impact: Informational
Confidence: Medium
 - [ ] ID-53
[QTIToken.batchUnlock(address[])](src/core/QTIToken.sol#L536-L573) has costly operations inside a loop:
	- [totalVotingPower = totalVotingPower - oldVotingPower](src/core/QTIToken.sol#L565)

src/core/QTIToken.sol#L536-L573


 - [ ] ID-54
[HedgerPool._closeSinglePosition(uint256,uint256,HedgerPool.HedgerInfo)](src/core/HedgerPool.sol#L428-L467) has costly operations inside a loop:
	- [totalMargin -= positionMargin](src/core/HedgerPool.sol#L453)
	Calls stack containing the loop:
		HedgerPool.closePositionsBatch(uint256[],uint256)

src/core/HedgerPool.sol#L428-L467


 - [ ] ID-55
[UserPool.batchDeposit(uint256[],uint256[])](src/core/UserPool.sol#L420-L485) has costly operations inside a loop:
	- [totalDeposits += netAmount](src/core/UserPool.sol#L478)

src/core/UserPool.sol#L420-L485


 - [ ] ID-56
[UserPool.batchStake(uint256[])](src/core/UserPool.sol#L635-L670) has costly operations inside a loop:
	- [totalStakes += qeuroAmount](src/core/UserPool.sol#L666)

src/core/UserPool.sol#L635-L670


 - [ ] ID-57
[HedgerPool._closeSinglePosition(uint256,uint256,HedgerPool.HedgerInfo)](src/core/HedgerPool.sol#L428-L467) has costly operations inside a loop:
	- [totalExposure -= positionSize](src/core/HedgerPool.sol#L454)
	Calls stack containing the loop:
		HedgerPool.closePositionsBatch(uint256[],uint256)

src/core/HedgerPool.sol#L428-L467


**More results were found, check [10](10)**
## cyclomatic-complexity
Impact: Informational
Confidence: High
 - [ ] ID-58
[QTIToken.batchLock(uint256[],uint256[])](src/core/QTIToken.sol#L449-L529) has a high cyclomatic complexity (16).

src/core/QTIToken.sol#L449-L529


## low-level-calls
Impact: Informational
Confidence: High
 - [ ] ID-59
Low level call in [HedgerPool.recoverETH(address)](src/core/HedgerPool.sol#L914-L923):
	- [(success,None) = to.call{value: balance}()](src/core/HedgerPool.sol#L921)

src/core/HedgerPool.sol#L914-L923


 - [ ] ID-60
Low level call in [stQEUROToken.recoverETH(address)](src/core/stQEUROToken.sol#L744-L753):
	- [(success,None) = to.call{value: balance}()](src/core/stQEUROToken.sol#L751)

src/core/stQEUROToken.sol#L744-L753


 - [ ] ID-61
Low level call in [AaveVault.recoverETH(address)](src/core/vaults/AaveVault.sol#L612-L620):
	- [(success,None) = to.call{value: balance}()](src/core/vaults/AaveVault.sol#L618)

src/core/vaults/AaveVault.sol#L612-L620


 - [ ] ID-62
Low level call in [QEUROToken.recoverETH(address)](src/core/QEUROToken.sol#L1161-L1170):
	- [(success,None) = to.call{value: balance}()](src/core/QEUROToken.sol#L1168)

. analyzed (76 contracts with 98 detectors), 155 result(s) found
INFO:Slither:slither-report.json exists already, the overwrite is prevented
INFO:Slither:slither-report.sarif exists already, the overwrite is prevented
src/core/QEUROToken.sol#L1161-L1170


 - [ ] ID-63
Low level call in [YieldShift.recoverETH(address)](src/core/yieldmanagement/YieldShift.sol#L835-L843):
	- [(success,None) = to.call{value: balance}()](src/core/yieldmanagement/YieldShift.sol#L841)

src/core/yieldmanagement/YieldShift.sol#L835-L843


**More results were found, check [10](10)**
## missing-inheritance
Impact: Informational
Confidence: High
 - [ ] ID-64
[ChainlinkOracle](src/oracle/ChainlinkOracle.sol#L41-L835) should inherit from [IChainlinkOracle](src/interfaces/IChainlinkOracle.sol#L11-L155)

src/oracle/ChainlinkOracle.sol#L41-L835


## unused-state
Impact: Informational
Confidence: High
 - [ ] ID-65
[QuantillonVault.lastValidEurUsdPrice](src/core/QuantillonVault.sol#L602) is never used in [QuantillonVault](src/core/QuantillonVault.sol#L72-L605)

src/core/QuantillonVault.sol#L602


## constable-states
Impact: Optimization
Confidence: High
 - [ ] ID-66
[HedgerPool.totalYieldEarned](src/core/HedgerPool.sol#L165) should be constant 

src/core/HedgerPool.sol#L165


 - [ ] ID-67
[QuantillonVault.lastValidEurUsdPrice](src/core/QuantillonVault.sol#L602) should be constant 

src/core/QuantillonVault.sol#L602


 - [ ] ID-68
[UserPool.lastYieldDistribution](src/core/UserPool.sol#L224) should be constant 

src/core/UserPool.sol#L224


 - [ ] ID-69
[UserPool.accumulatedYieldPerShare](src/core/UserPool.sol#L219) should be constant 

src/core/UserPool.sol#L219


 - [ ] ID-70
[UserPool.totalYieldDistributed](src/core/UserPool.sol#L229) should be constant 

src/core/UserPool.sol#L229


**More results were found, check [10](10)**
